package workbox_routing;

/**
	The Router can be used to process a FetchEvent through one or more
	[Routes]{@link module:workbox-routing.Route} responding  with a Request if
	a matching route exists.
	
	If no route matches a given a request, the Router will use a "default"
	handler if one is defined.
	
	Should the matching Route throw an error, the Router will use a "catch"
	handler if one is defined to gracefully deal with issues and respond with a
	Request.
	
	If a request matches multiple routes, the **earliest** registered route will
	be used to respond to the request.
**/
@:jsRequire("workbox-routing", "Router") extern class Router {
	/**
		Initializes a new Router.
	**/
	function new();
	private final _routes : Dynamic;
	private final _defaultHandlerMap : Dynamic;
	@:optional
	private var _catchHandler : Dynamic;
	final routes : js.lib.Map<workbox_routing.utils.constants.HTTPMethod, Array<Route>>;
	/**
		Adds a fetch event listener to respond to events when a route matches
		the event's request.
	**/
	function addFetchListener():Void;
	/**
		Adds a message event listener for URLs to cache from the window.
		This is useful to cache resources loaded on the page prior to when the
		service worker started controlling it.
		
		The format of the message data sent from the window should be as follows.
		Where the `urlsToCache` array may consist of URL strings or an array of
		URL string + `requestInit` object (the same as you'd pass to `fetch()`).
		
		```
		{
		   type: 'CACHE_URLS',
		   payload: {
		     urlsToCache: [
		       './script1.js',
		       './script2.js',
		       ['./script3.js', {mode: 'no-cors'}],
		     ],
		   },
		}
		```
	**/
	function addCacheListener():Void;
	/**
		Apply the routing rules to a FetchEvent object to get a Response from an
		appropriate Route's handler.
	**/
	function handleRequest(__0:{ var request : js.html.Request; var event : Dynamic; }):Null<js.lib.Promise<js.html.Response>>;
	/**
		Checks a request and URL (and optionally an event) against the list of
		registered routes, and if there's a match, returns the corresponding
		route along with any params generated by the match.
	**/
	function findMatchingRoute(__0:workbox_core.RouteMatchCallbackOptions):{
		@:optional
		var route : Route;
		@:optional
		var params : ts.AnyOf2<Array<String>, workbox_core.MapLikeObject>;
	};
	/**
		Define a default `handler` that's called when no routes explicitly
		match the incoming request.
		
		Each HTTP method ('GET', 'POST', etc.) gets its own default handler.
		
		Without a default handler, unmatched requests will go against the
		network as if there were no service worker present.
	**/
	function setDefaultHandler(handler:workbox_core.RouteHandler, ?method:workbox_routing.utils.constants.HTTPMethod):Void;
	/**
		If a Route throws an error while handling a request, this `handler`
		will be called and given a chance to provide a response.
	**/
	function setCatchHandler(handler:workbox_core.RouteHandler):Void;
	/**
		Registers a route with the router.
	**/
	function registerRoute(route:Route):Void;
	/**
		Unregisters a route with the router.
	**/
	function unregisterRoute(route:Route):Void;
	static var prototype : Router;
}