package workbox_strategies;

/**
	A class created every time a Strategy instance instance calls
	[handle()]{@link module:workbox-strategies.Strategy~handle} or
	[handleAll()]{@link module:workbox-strategies.Strategy~handleAll} that wraps all fetch and
	cache actions around plugin callbacks and keeps track of when the strategy
	is "done" (i.e. all added `event.waitUntil()` promises have resolved).
**/
@:jsRequire("workbox-strategies", "StrategyHandler") extern class StrategyHandler {
	/**
		Creates a new instance associated with the passed strategy and event
		that's handling the request.
		
		The constructor also initializes the state that will be passed to each of
		the plugins handling this request.
	**/
	function new(strategy:Strategy, options:workbox_core.HandlerCallbackOptions);
	var request : js.html.Request;
	@:optional
	var url : js.html.URL;
	var event : Dynamic;
	@:optional
	var params : Dynamic;
	private var _cacheKeys : Dynamic;
	private final _strategy : Dynamic;
	private final _extendLifetimePromises : Dynamic;
	private final _handlerDeferred : Dynamic;
	private final _plugins : Dynamic;
	private final _pluginStateMap : Dynamic;
	/**
		Fetches a given request (and invokes any applicable plugin callback
		methods) using the `fetchOptions` (for non-navigation requests) and
		`plugins` defined on the `Strategy` object.
		
		The following plugin lifecycle methods are invoked when using this method:
		- `requestWillFetch()`
		- `fetchDidSucceed()`
		- `fetchDidFail()`
	**/
	function fetch(input:js.html.RequestInfo):js.lib.Promise<js.html.Response>;
	/**
		Calls `this.fetch()` and (in the background) runs `this.cachePut()` on
		the response generated by `this.fetch()`.
		
		The call to `this.cachePut()` automatically invokes `this.waitUntil()`,
		so you do not have to manually call `waitUntil()` on the event.
	**/
	function fetchAndCachePut(input:js.html.RequestInfo):js.lib.Promise<js.html.Response>;
	/**
		Matches a request from the cache (and invokes any applicable plugin
		callback methods) using the `cacheName`, `matchOptions`, and `plugins`
		defined on the strategy object.
		
		The following plugin lifecycle methods are invoked when using this method:
		- cacheKeyWillByUsed()
		- cachedResponseWillByUsed()
	**/
	function cacheMatch(key:js.html.RequestInfo):js.lib.Promise<Null<js.html.Response>>;
	/**
		Puts a request/response pair in the cache (and invokes any applicable
		plugin callback methods) using the `cacheName` and `plugins` defined on
		the strategy object.
		
		The following plugin lifecycle methods are invoked when using this method:
		- cacheKeyWillByUsed()
		- cacheWillUpdate()
		- cacheDidUpdate()
	**/
	function cachePut(key:js.html.RequestInfo, response:js.html.Response):js.lib.Promise<Bool>;
	/**
		Checks the list of plugins for the `cacheKeyWillBeUsed` callback, and
		executes any of those callbacks found in sequence. The final `Request`
		object returned by the last plugin is treated as the cache key for cache
		reads and/or writes. If no `cacheKeyWillBeUsed` plugin callbacks have
		been registered, the passed request is returned unmodified
	**/
	function getCacheKey(request:js.html.Request, mode:String):js.lib.Promise<js.html.Request>;
	/**
		Returns true if the strategy has at least one plugin with the given
		callback.
	**/
	function hasCallback<C>(name:C):Bool;
	/**
		Runs all plugin callbacks matching the given name, in order, passing the
		given param object (merged ith the current plugin state) as the only
		argument.
		
		Note: since this method runs all plugins, it's not suitable for cases
		where the return value of a callback needs to be applied prior to calling
		the next callback. See
		[`iterateCallbacks()`]{@link module:workbox-strategies.StrategyHandler#iterateCallbacks}
		below for how to handle that case.
	**/
	function runCallbacks<C>(name:C, param:{ var request : Dynamic; var event : Dynamic; }):js.lib.Promise<Void>;
	/**
		Accepts a callback and returns an iterable of matching plugin callbacks,
		where each callback is wrapped with the current handler state (i.e. when
		you call each callback, whatever object parameter you pass it will
		be merged with the plugin's current state).
	**/
	function iterateCallbacks<C>(name:C):js.lib.Generator<Dynamic, Dynamic, Any>;
	/**
		Adds a promise to the
		[extend lifetime promises]{@link https://w3c.github.io/ServiceWorker/#extendableevent-extend-lifetime-promises}
		of the event event associated with the request being handled (usually a
		`FetchEvent`).
		
		Note: you can await
		[`doneWaiting()`]{@link module:workbox-strategies.StrategyHandler~doneWaiting}
		to know when all added promises have settled.
	**/
	function waitUntil<T>(promise:js.lib.Promise<T>):js.lib.Promise<T>;
	/**
		Returns a promise that resolves once all promises passed to
		[`waitUntil()`]{@link module:workbox-strategies.StrategyHandler~waitUntil}
		have settled.
		
		Note: any work done after `doneWaiting()` settles should be manually
		passed to an event's `waitUntil()` method (not this handler's
		`waitUntil()` method), otherwise the service worker thread my be killed
		prior to your work completing.
	**/
	function doneWaiting():js.lib.Promise<Void>;
	/**
		Stops running the strategy and immediately resolves any pending
		`waitUntil()` promises.
	**/
	function destroy():Void;
	/**
		This method will call cacheWillUpdate on the available plugins (or use
		status === 200) to determine if the Response is safe and valid to cache.
	**/
	function _ensureResponseSafeToCache(response:js.html.Response):js.lib.Promise<Null<js.html.Response>>;
	static var prototype : StrategyHandler;
}